---
marp: true
---

# 데코레이터 패턴

---

## 데코레이터 패턴이란?

데코레이터 패턴에서는 객체의 추가적인 요건을 동적으로 추가한다

---

## 데코레이터 패턴을 적용하지 않은 예제

한 Beverage를 상속받는 여러 음료 서브클래스들이 존재
![image](https://user-images.githubusercontent.com/19178129/66301842-db655a80-e932-11e9-9641-1270737be80e.png)

---

이하의 그림처럼 상속을 통해 코드를 확장해야 한다.

음료를 추가하거나 토핑을 추가할 경우 코드가 중복되고 더 많은 서브클래스들이 생성된다.

![image](https://user-images.githubusercontent.com/19178129/66301625-73167900-e932-11e9-88d3-50ebae57a145.png)

---

## 단점

1. 휘핑 크림을 두번 넣을려면 this.twoWhip이라는 변수를 만들어야 함
2. 새로운 재료를 넣으려면 부모 클래스의 생성자, getCost함수를 수정해야 함
3. getCost함수가 if문 반복으로 매우 지저분해짐
4. 재료의 가격이 수정될 경우 부모 클래스를 수정해야 함

---

## 적용된 디자인 원칙

### OCP

- 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 있어서는 닫혀 있어야 한다.
- 즉 기존 코드는 건드리지 않은 채로 확장을 통해서 새로운 행동을 간단하게 추가할 수 있도록 하면,
  새로운 기능을 유연하게 추가할 수 있어, 주변 환경에 잘 적응할 수 있으면서도 강하고 튼튼한 디자인을 만들 수 있다.
- 여기서는 재료를 새롭게 추가하려고 해도 부모 클래스를 수정하지 않아도 되므로 코드 변경을 하지 않아도 확장 가능하다고 볼 수 있다.
